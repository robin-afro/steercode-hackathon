// Doc Generator Service
// Handles AI-powered documentation generation with context awareness

import { Mistral } from '@mistralai/mistralai'
import { Component } from './component-extractor'
import { WorkPlanItem } from './planner'
import { ContextWindow, ContextLoader } from './context-loader'
import { createClient } from '@/lib/supabase/server'

export interface GenerationResult {
  success: boolean
  document?: GeneratedDocument
  links?: DocumentLink[]
  error?: string
  metrics: GenerationMetrics
}

export interface GeneratedDocument {
  title: string
  content: string
  summary?: string
}

export interface DocumentLink {
  targetDocPath: string
  linkType: string
  confidence: number
}

export interface GenerationMetrics {
  tokensInput: number
  tokensOutput: number
  generationTimeMs: number
  modelUsed: string
  costEstimated?: number
}

export interface GenerationConfig {
  model: string
  maxTokens: number
  temperature: number
  includeContext: boolean
  extractLinks: boolean
  generateSummary: boolean
}

export class DocGenerator {
  private readonly mistral: Mistral
  private readonly contextLoader: ContextLoader
  
  private readonly defaultConfig: GenerationConfig = {
    model: 'mistral-large-latest',
    maxTokens: 4000,
    temperature: 0.1,
    includeContext: true,
    extractLinks: true,
    generateSummary: true
  }

  constructor() {
    this.mistral = new Mistral({
      apiKey: process.env.MISTRAL_API_KEY!,
    })
    this.contextLoader = new ContextLoader()
  }

  async generateDocument(
    repositoryId: string,
    workItem: WorkPlanItem,
    components: Component[],
    repositoryInfo: any,
    config: Partial<GenerationConfig> = {}
  ): Promise<GenerationResult> {
    const startTime = Date.now()
    const finalConfig = { ...this.defaultConfig, ...config }

    try {
      // Load context window if requested
      let contextWindow: ContextWindow | null = null
      if (finalConfig.includeContext) {
        contextWindow = await this.contextLoader.loadContextWindow(
          repositoryId,
          workItem.docPath,
          { maxTokens: 2000, maxDocuments: 20 }
        )
      }

      // Build the prompt
      const prompt = await this.buildPrompt(workItem, components, repositoryInfo, contextWindow)
      
      // Generate documentation
      const response = await this.mistral.chat.complete({
        model: finalConfig.model,
        messages: [{ role: 'user', content: prompt }],
        maxTokens: finalConfig.maxTokens,
        temperature: finalConfig.temperature
      })

      const content = response.choices?.[0]?.message?.content
      if (!content || typeof content !== 'string') {
        throw new Error('No content generated by AI model')
      }

      // Parse the generated content
      const parsedResult = this.parseGeneratedContent(content)
      
      // Extract links if requested
      let links: DocumentLink[] = []
      if (finalConfig.extractLinks && contextWindow) {
        links = await this.extractLinks(parsedResult.content, contextWindow)
      }

      // Generate summary if requested
      let summary: string | undefined
      if (finalConfig.generateSummary) {
        summary = this.generateSummary(parsedResult.content)
      }

      const endTime = Date.now()
      const metrics: GenerationMetrics = {
        tokensInput: this.estimateTokens(prompt),
        tokensOutput: this.estimateTokens(content),
        generationTimeMs: endTime - startTime,
        modelUsed: finalConfig.model,
        costEstimated: this.estimateCost(
          this.estimateTokens(prompt),
          this.estimateTokens(content),
          finalConfig.model
        )
      }

      return {
        success: true,
        document: {
          title: parsedResult.title || workItem.title,
          content: parsedResult.content,
          summary
        },
        links,
        metrics
      }

    } catch (error) {
      const endTime = Date.now()
      
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        metrics: {
          tokensInput: 0,
          tokensOutput: 0,
          generationTimeMs: endTime - startTime,
          modelUsed: finalConfig.model
        }
      }
    }
  }

  private async buildPrompt(
    workItem: WorkPlanItem,
    components: Component[],
    repositoryInfo: any,
    contextWindow: ContextWindow | null
  ): Promise<string> {
    const contextSection = contextWindow && contextWindow.documents.length > 0
      ? this.buildContextSection(contextWindow)
      : ''

    const componentsSection = this.buildComponentsSection(components)
    
    return `You are Lookas, an expert AI code documentation assistant.

REPOSITORY: ${repositoryInfo.name || 'Unknown'}
DOCUMENT PATH: ${workItem.docPath}
DOCUMENT TYPE: ${workItem.documentType}

${contextSection}

COMPONENTS TO DOCUMENT:
${componentsSection}

TASK:
Create comprehensive, beginner-friendly documentation for this ${workItem.documentType}. The documentation should:

1. **Overview**: Provide a clear 2-3 sentence summary of what this ${workItem.documentType} does
2. **Purpose**: Explain why this code exists and what problems it solves
3. **Key Components**: Document each component's role and functionality
4. **Relationships**: Describe how components interact with each other
5. **Usage Examples**: Include practical examples where applicable
6. **Implementation Details**: Highlight important patterns, conventions, or gotchas

FORMATTING GUIDELINES:
- Use clear, jargon-free language suitable for junior developers
- Include code examples where helpful
- Use markdown formatting for better readability
- When referencing existing documented components, use this format: {{link:target.doc.path}}

${contextWindow ? 'CONTEXT AWARENESS: Reference related documentation when relevant, but avoid duplication. Build on existing knowledge.' : ''}

OUTPUT FORMAT:
Provide your response as a well-structured markdown document. Start with a clear title and organize content logically with appropriate headings.`
  }

  private buildContextSection(contextWindow: ContextWindow): string {
    if (contextWindow.documents.length === 0) {
      return ''
    }

    const contextDocs = contextWindow.documents
      .slice(0, 10) // Limit context to avoid overwhelming the prompt
      .map(doc => `- **${doc.title}** (${doc.documentPath}): ${doc.summary}`)
      .join('\n')

    return `EXISTING DOCUMENTATION CONTEXT:
The following documentation already exists in this repository:

${contextDocs}

`
  }

  private buildComponentsSection(components: Component[]): string {
    if (components.length === 0) {
      return 'No specific components identified.'
    }

    return components.map(component => {
      const relationsText = component.relations.length > 0
        ? `\n  Relations: ${component.relations.map(r => `${r.type} ${r.target}`).join(', ')}`
        : ''

      return `- **${component.name}** (${component.type})${relationsText}
  Location: ${component.parentPath}${component.startLine ? `:${component.startLine}` : ''}
  ${component.metadata ? `Metadata: ${JSON.stringify(component.metadata, null, 2)}` : ''}`
    }).join('\n\n')
  }

  private parseGeneratedContent(content: string): { title?: string, content: string } {
    // Try to extract title from the first heading
    const titleMatch = content.match(/^#\s+(.+)$/m)
    const title = titleMatch ? titleMatch[1].trim() : undefined

    return {
      title,
      content: content.trim()
    }
  }

  private async extractLinks(content: string, contextWindow: ContextWindow): Promise<DocumentLink[]> {
    const links: DocumentLink[] = []
    
    // Extract {{link:path}} patterns
    const linkRegex = /\{\{link:([^}]+)\}\}/g
    let match

    while ((match = linkRegex.exec(content)) !== null) {
      const targetPath = match[1].trim()
      
      // Verify the target exists in context
      const targetExists = contextWindow.documents.some(doc => 
        doc.documentPath === targetPath
      )

      if (targetExists) {
        links.push({
          targetDocPath: targetPath,
          linkType: 'references',
          confidence: 0.9
        })
      }
    }

    // Additional heuristics for implicit links could be added here
    
    return links
  }

  private generateSummary(content: string): string {
    // Extract first paragraph or first few sentences
    const firstParagraph = content
      .replace(/^#+\s+.*$/gm, '') // Remove headings
      .split('\n\n')[0] // Get first paragraph
      ?.trim()

    if (!firstParagraph) {
      return 'Documentation content'
    }

    // Limit to ~280 characters
    if (firstParagraph.length <= 280) {
      return firstParagraph
    }

    // Find the last complete sentence within the limit
    const truncated = firstParagraph.substring(0, 280)
    const lastSentence = truncated.lastIndexOf('.')
    
    if (lastSentence > 100) {
      return truncated.substring(0, lastSentence + 1)
    }

    return truncated + '...'
  }

  private estimateTokens(text: string): number {
    // Rough estimation: ~4 characters per token
    return Math.ceil(text.length / 4)
  }

  private estimateCost(inputTokens: number, outputTokens: number, model: string): number {
    // Pricing estimates for Mistral models (as of 2024)
    const pricing: Record<string, { input: number, output: number }> = {
      'mistral-large-latest': { input: 0.000008, output: 0.000024 }, // $8/$24 per 1M tokens
      'mistral-medium-latest': { input: 0.0000027, output: 0.0000081 }, // $2.7/$8.1 per 1M tokens
      'mistral-small-latest': { input: 0.000001, output: 0.000003 } // $1/$3 per 1M tokens
    }

    const modelPricing = pricing[model] || pricing['mistral-large-latest']
    return (inputTokens * modelPricing.input) + (outputTokens * modelPricing.output)
  }

  async saveGenerationMetrics(
    repositoryId: string,
    documentId: string,
    metrics: GenerationMetrics
  ): Promise<void> {
    try {
      const supabase = await createClient()
      
      await supabase
        .from('generation_metrics')
        .insert({
          repository_id: repositoryId,
          document_id: documentId,
          model_used: metrics.modelUsed,
          tokens_input: metrics.tokensInput,
          tokens_output: metrics.tokensOutput,
          cost_estimated: metrics.costEstimated || 0,
          generation_time_ms: metrics.generationTimeMs
        })
    } catch (error) {
      console.warn('Failed to save generation metrics:', error)
      // Don't throw - metrics are optional
    }
  }

  // Specialized prompts for different document types
  async generateOverviewDocument(
    repositoryInfo: any,
    totalComponents: number,
    mainLanguages: string[]
  ): Promise<GenerationResult> {
    const startTime = Date.now()

    try {
      const prompt = `You are Lookas, an expert AI code documentation assistant.

Create a comprehensive project overview for the repository: ${repositoryInfo.name}

REPOSITORY DETAILS:
- Name: ${repositoryInfo.name}
- Description: ${repositoryInfo.description || 'No description provided'}
- Primary Language: ${repositoryInfo.language || 'Mixed'}
- Total Components Analyzed: ${totalComponents}
- Technologies: ${mainLanguages.join(', ')}

TASK:
Create an engaging project overview that includes:

1. **Project Summary**: What this project does and its main purpose
2. **Architecture Overview**: High-level structure and organization
3. **Key Technologies**: Technologies and frameworks used
4. **Getting Started**: Basic information for new developers
5. **Project Structure**: Overview of main directories and their purposes

Keep the documentation welcoming for new contributors and provide a clear mental model of the project.

OUTPUT: Provide a well-structured markdown document.`

      const response = await this.mistral.chat.complete({
        model: this.defaultConfig.model,
        messages: [{ role: 'user', content: prompt }],
        maxTokens: 2000,
        temperature: 0.1
      })

      const content = response.choices?.[0]?.message?.content
      if (!content || typeof content !== 'string') {
        throw new Error('No content generated for overview')
      }

      const parsedResult = this.parseGeneratedContent(content)
      const endTime = Date.now()

      return {
        success: true,
        document: {
          title: parsedResult.title || `${repositoryInfo.name} - Project Overview`,
          content: parsedResult.content,
          summary: this.generateSummary(parsedResult.content)
        },
        links: [],
        metrics: {
          tokensInput: this.estimateTokens(prompt),
          tokensOutput: this.estimateTokens(content),
          generationTimeMs: endTime - startTime,
          modelUsed: this.defaultConfig.model,
          costEstimated: this.estimateCost(
            this.estimateTokens(prompt),
            this.estimateTokens(content),
            this.defaultConfig.model
          )
        }
      }

    } catch (error) {
      const endTime = Date.now()
      
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        metrics: {
          tokensInput: 0,
          tokensOutput: 0,
          generationTimeMs: endTime - startTime,
          modelUsed: this.defaultConfig.model
        }
      }
    }
  }
} 